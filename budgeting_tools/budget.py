# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/budget.ipynb.

# %% auto 0
__all__ = ['Budget']

# %% ../nbs/budget.ipynb 3
import os
import datetime
import requests
import json
import pandas as pd

# %% ../nbs/budget.ipynb 4
class Budget:
    """A class to represent a YNAB budget for a given month and provides tooling
    to generate and programatically calculate and set budgets"""

    def __init__(self, date=None):
        """Initializes the Budget object with the date of the budget to be fetched. If no date is provided, the current month is used."""
        self.date = date
        self.token = os.environ["YNAB_TOKEN"]
        if self.token == None:
            raise ValueError("YNAB_TOKEN environment variable not set")
        self.fetch_budget()

    def fetch_budget(self):
        """Fetches budget data from YNAB API and stores it in the Budget object"""
        if self.date == None:
            date = datetime.datetime.strftime(datetime.datetime.now(), "%Y-%m") + "-01"
        else:
            date = datetime.datetime.strftime(self.date, "%Y-%m") + "-01"
        month = requests.get(
            f"https://api.youneedabudget.com/v1/budgets/last-used/months/{date}?access_token={self.token}"
        )
        month_data = month.json()["data"]["month"]
        self.month = month_data["month"]
        self.income = month_data["income"]
        self.budgeted = month_data["budgeted"]
        self.activity = month_data["activity"]
        self.to_be_budgeted = month_data["to_be_budgeted"]
        self.age_of_money = month_data["age_of_money"]
        self.categories_df = pd.DataFrame(month_data["categories"])

    def generate_budget_template_csv(self, filename="base_budget.csv"):
        """Generates a base budget CSV file for the month"""
        budget_template = pd.DataFrame(
            {
                "category": self.categories_df.query("hidden == False")
                .name.unique()
                .tolist(),
                "fixed": None,
                "pre_fixed": None,
                "rollover": None,
                "amount": None,
            }
        )
        budget_template.to_csv(filename, index=False)
        return budget_template

    def calculate_budget_from_template(
        self, template_path: str, spillover_category: str
    ):
        """Calculate the budget amounts for each category based off of the budget
        template"""
        budget_template = pd.read_csv(template_path)
        if (
            budget_template.query("fixed == False & pre_fixed == False")["amount"].sum()
            != 1
        ):
            raise ValueError(
                "The sum of the amounts for the variable categories must equal 1"
            )
        to_be_budgeted = self.to_be_budgeted
        pre_fixed_df = budget_template.query("pre_fixed == True").copy()
        fixed_df = budget_template.query("fixed == True").copy()
        variable_df = budget_template.query(
            "fixed == False & pre_fixed == False"
        ).copy()
        no_roll_over_categories = budget_template.query(
            "rollover == False"
        ).category.tolist()
        pre_fixed_df["budgeted"] = pre_fixed_df["amount"] * to_be_budgeted
        fixed_df["budgeted"] = fixed_df["amount"] * 1000
        if (
            pre_fixed_df["budgeted"].sum() + fixed_df["budgeted"].sum()
        ) > to_be_budgeted:
            raise ValueError("The fixed and pre-fixed categories exceed to be budgeted")
        remaining_to_be_budgeted = (
            to_be_budgeted - pre_fixed_df["budgeted"].sum() - fixed_df["budgeted"].sum()
        )
        variable_df["budgeted"] = variable_df.amount * remaining_to_be_budgeted
        full_budget = pd.concat([pre_fixed_df, fixed_df, variable_df])
        # Handle no rollover categories
        for category in no_roll_over_categories:
            remaining = self.categories_df.query(f'name == "{category}"').balance.sum()
            adjustment = (
                full_budget.query(f'category == "{category}"')["budgeted"].sum()
                - remaining
            )
            full_budget.loc[full_budget.category == category, "budgeted"] = adjustment
        # round all the budgeted amounts to the nearest cent
        full_budget["budgeted"] = (full_budget["budgeted"] / 1000).round(2)
        # compare the budgeted amount to the rounded to be budgeted amount
        round_to_be_budgeted = round(self.to_be_budgeted / 1000, 2)

        leftover = round_to_be_budgeted - full_budget.budgeted.sum()
        # put the leftover in the spillover category
        full_budget.loc[
            full_budget.category == spillover_category, "budgeted"
        ] += leftover

        if full_budget.budgeted.sum() != round_to_be_budgeted:
            raise ValueError(
                f"The budgeted amount does not equal to be budgeted, you are off by {(round_to_be_budgeted - full_budget.budgeted.sum())/1000}"
            )
        full_budget["budgeted"] = full_budget["budgeted"] * 1000
        self.new_budget = full_budget

    def set_budget(self):
        """Function to take in a dictionary with budget categories and amounts and write them to a month's budget in YNAB"""
        budget_dictionary = dict(
            zip(self.new_budget.category, self.new_budget.budgeted)
        )
        month = requests.get(
            f"https://api.youneedabudget.com/v1/budgets/last-used/months/{self.date}?access_token={self.token}"
        )
        category_balances = pd.DataFrame(
            json.loads(month.content)["data"]["month"]["categories"]
        )
        category_ids = dict(
            zip(category_balances["name"].values, category_balances["id"].values)
        )
        for cat in budget_dictionary.keys():
            category_id = category_ids[cat]
            data = {"category": {"budgeted": int(budget_dictionary[cat])}}
            cat_response = requests.patch(
                f"https://api.youneedabudget.com/v1/budgets/last-used/months/{self.date}/categories/{category_id}?access_token={self.token}",
                json=data,
            )
            if not cat_response.ok:
                raise ValueError(
                    f"There was an error updating the budget for {cat}. The error was {cat_response.content}"
                )
        print("Budget Updated!")

    def zero_out(self):
        """Function to zero out all budget categories"""
        month = requests.get(
            f"https://api.youneedabudget.com/v1/budgets/last-used/months/{self.date}?access_token={self.token}"
        )
        category_balances = pd.DataFrame(
            json.loads(month.content)["data"]["month"]["categories"]
        )
        category_ids = dict(
            zip(category_balances["name"].values, category_balances["id"].values)
        )
        for cat in category_ids.values():
            data = {"category": {"budgeted": 0}}
            cat_response = requests.patch(
                f"https://api.youneedabudget.com/v1/budgets/last-used/months/{self.date}/categories/{cat}?access_token={self.token}",
                json=data,
            )
            if not cat_response.ok:
                print(cat_response.content)
        print("Budget Zeroed Out!")
